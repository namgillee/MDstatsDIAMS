#' Compute local false discovery rates from p-values
#'
#' The p-values are transformed to z-values, then, lfdr values are computed.
#' @param pvalues A vector of p-values
#' @param known_target_df A data frame with Uniprot ID's at the first column
#'   named 'UniprotID'. All the proteins are regarded as on-targets.
#' @param eps A small floating number that sets a lower bound on the p-values.
#' @return A vector of local fdr values, of the same length as pvalues
#' @export
local_fdr <- function(
  pvalues, known_target_df, eps = 5e-16
) {
  # Transform p-values to z-values
  # Because p-value is not symmetric (small p implies significance) but
  # z-value is symmetric (large z > 0 or small z < 0 implies significance),
  # z-values are generated by combining z and -z.
  one_minus_p <- 1 - pvalues[!is.na(pvalues)]
  one_minus_p[one_minus_p > (1 - eps)] <- 1 - eps
  z_pos <- stats::qnorm(0.5 + one_minus_p / 2)
  zvalues <- c(z_pos, -z_pos)

  # Compute lfdr using z-values
  lfdr_out <- fdrtool::fdrtool(zvalues, "normal", plot = FALSE)

  # The output lfdr has the same length as p-values
  lfdr <- rep(NaN, length(pvalues))
  lfdr[!is.na(pvalues)] <- lfdr_out$lfdr[1 : sum(!is.na(pvalues))]

  return(lfdr)
}


#' Append local false discovery (lfdr) score to the statistical testing results.
#'
#' Append local false discovery (lfdr) score to the statistical testing results.
#' In addition, append is_target column if known on-target data is available.
#' @param ttest_result A list of lists of statistical test result tables,
#'   which are obtained by run_ttest().
#' @param known_target_df An optional data frame for known target data frame.
#'   The 'UniprotID' column at the first column is the list of uniprot IDs.
#' @param is_target_column Name of the boolean column for indicating on-targets
#'   by TRUE, and FALSE for not-on-targets.
#' @param protein_column  Column name for protein id in known_target_df
#' @return A list of lists of data frames with the original columns and an
#'   additional `lfdr` column. The `is_target` column is optionally appended
#'   only when `known_target_df` is not NULL.
#' @export
compute_lfdr_result <- function(
  ttest_result, known_target_df = NULL, is_target_column = "is_target",
  protein_column = "UniprotID"
) {
  for (method_name in names(ttest_result)) {
    for (comparison in names(ttest_result[[method_name]])) {
      p_value <- ttest_result[[method_name]][[comparison]]$p.value
      lfdr <- local_fdr(p_value)
      ttest_result[[method_name]][[comparison]]$lfdr <- lfdr

      if (!is.null(known_target_df)) {
        protein_id <- ttest_result[[method_name]][[comparison]]$protein_id
        is_target <- (protein_id %in% known_target_df[[protein_column]])
        ttest_result[[method_name]][[comparison]][[is_target_column]] <-
          is_target
      }
    }
  }
  return(ttest_result)
}


#' Compute sensitivity and specificity from statistical significance result
#'
#' @param is_target A boolean vector for labeling true target.
#' @param q_values Significance levels. Smaller value implies more significance.
#' @param random_seed Random seed. Used for shuffling input values.
#' @return data frame of nine metrics: total, total_pos, total_neg, count_p,
#'   count_tp, count_fp, count_fn, specificity, sensitivity. The count_p is
#'   a vector of the number of positives, which increases from 1 to total.
.compute_sensitivity_table <- function(
  is_target, q_values, random_seed = 1111
) {
  if (length(is_target) != length(q_values)) {
    warning("Length of is_target must be equal to that of q_values.")
    return(NULL)
  }

  idx_not_na <- !is.na(is_target) & !is.na(q_values)
  is_target <- is_target[idx_not_na]
  q_values <- q_values[idx_not_na]

  count_p <- count_tp <- count_fp <- count_fn <- specificity <- sensitivity <-
    double(length = length(q_values))

  ## constants
  total <- length(q_values)
  count_p <- 1 : total
  total_neg <- sum(!is_target)
  total_pos <- sum(is_target)

  ## variables
  ## Shuffling values is necessary when q-values has many duplicated values.
  set.seed(random_seed)
  count_tp <- rep(0, total)
  for (rep in 1:100) {
    shuffhled_df <- dplyr::sample_frac(data.frame(is_target, q_values), 1L)
    shuffhled_df <- shuffhled_df[order(shuffhled_df$q_values), ]
    count_tp <- count_tp + cumsum(shuffhled_df$is_target) / 100
  }
  count_fp <- count_p - count_tp
  count_fn <- total_pos - count_tp
  specificity <- (total_neg - count_fp) / total_neg
  sensitivity <- count_tp / total_pos

  return(data.frame(total, total_pos, total_neg, count_p, count_tp, count_fp,
                    count_fn, specificity, sensitivity))
}


#' Compute sensitivity and specificity from statistical significance result
#'
#' @param lfdr_result A list of lists of statistical test result tables,
#'   which are obtained by run_ttest(), but each result table has two
#'   additional columns specified by 'is_target_column' and 'q_value_column'.
#' @param is_target_column Name of the column having a boolean vector for
#'   labeling true target.
#' @param q_value_column Name of the column having significance levels: A
#'   smaller value implies more significance.
#' @param group_column Names of the columns for grouping the rows. Defaults
#'   to c('experiment', 'protein_id')
#' @param random_seed Random seed. Used for shuffling input values.
#' @return A list of lists of data frames having nine metrics:
#'   total, total_pos, total_neg, count_p, count_tp, count_fp, count_fn,
#'   specificity, sensitivity. The count_p is a vector of the number of
#'   positives, which is set to increase from 1 to total.
#' @export
compute_sensitivity_result <- function(
  lfdr_result,
  is_target_column = "is_target",
  q_value_column = "lfdr",
  group_column = c("experiment", "protein_id"),
  random_seed = 11111
) {
  minimum_with_na <- function(values) {
    ifelse(all(is.na(values)), NA, min(values, na.rm = TRUE))
  }

  # Iterate for each method
  sensitivity_result <- lapply(lfdr_result, function(method_result) {
    # Iterate for each comparison
    lapply(method_result, function(comparison_table) {
      # Group rows & summarize with p.value & lfdr
      grouped_table <- comparison_table %>%
        dplyr::group_by_at(group_column) %>%
        dplyr::summarize_at(
          unique(c("p.value", q_value_column)),
          minimum_with_na
        )
      # Below lines may be redundant but remain here to deal with unexpected.
      grouped_table[["p.value"]][
        is.infinite(grouped_table[["p.value"]])
      ] <- NA
      grouped_table[[q_value_column]][
        is.infinite(grouped_table[[q_value_column]])
      ] <- NA

      # Append is_target column
      target_table <- comparison_table %>%
        dplyr::group_by_at(group_column) %>%
        dplyr::summarize_at(is_target_column, dplyr::first)

      grouped_table <- grouped_table %>%
        dplyr::left_join(target_table, by = group_column)

      # Compute sensitivity table
      sensitivity_table <- .compute_sensitivity_table(
        is_target = grouped_table[[is_target_column]],
        q_values = grouped_table[[q_value_column]],
        random_seed = random_seed
      )
    })
  })
  return(sensitivity_result)
}
